#!/bin/bash

###
# usage: ./teclyn -[a, b, d, e, f, i, n, s, t] OPTION
# -a gair
#       adds 'gair'  to dictionary (may include
#       dictionary tags on the end e.g.  /AFG).
# -b
#       builds the zipped  libreoffice package.
# -d
#	git diff the dictionary file and  print
#	only  the  words  that   have   changed
#	(usually they have been added).
# -e gair
#       use 'wordforms' from hunspell to expand
#       the   given  word  with  all   relevant
#       permitted  affixes in  the  dictionary.
# -f gair
#	find the word or word  fragment  in the
#	dictionary  file and print all matches:
#	accepts regex.
# -i
#	repeatedly  prompt for words,  then  -a
#	add them (this first checks if they are
#	in  the  dictionary   already,  and  by
#	default auto-tags with treigladau tags.
# -n rhestr_o_eiriau.txt
#	search through a list of words (one per
#	line) to find ones unknown to the  dict
#	and add them to an output file.
# -s gair
#	check  whether  word  'gair'  (or words
#	in file 'gair') are in the dictionary.
# -t
#	sort the .dic file  alphabetically  and
#	add the number of lines to the top.
###

PINK='\033[95m'
BLUE='\033[94m'
YELLOW='\033[93m'
GREEN='\033[92m'
RED='\033[91m'
ENDC='\033[0m'

parse () {
	###
	# get command line options
	###
	case "$1" in
		-a|--add)
			ychwanegu "$2"
			shift
			;;
		-b|--build)
			adeiladu
			shift
			;;
		-d|--diff)
			geiriau_a_newidiwyd
			shift
			;;
		-e|--expand)
			ystyried dictionaries/cy_GB.aff dictionaries/cy_GB.dic "$2" | sort -u
			shift
			;;
		-f|--find)
			ffeindio "$2"
			shift
			;;
		-i|--insert)
			insertmode "$2"
			shift
			;;
		-n|--new)
			newydd "$2"
			shift
			;;
		-s|--spell)
			gwirio "$2"
			shift
			;;
		-t|--tidy)
			tacluso "dictionaries/cy_GB.dic"
			shift
			;;
		--)
			shift
			break
			;;
		*)
			echo "usage: ./teclyn -[a, b, e, f]
-a gair
	adds 'gair'  to dictionary (may include
	dictionary tags on the end e.g.  /AFG).
-b
	builds the zipped  libreoffice package.
-d
	git diff the dictionary file and  print
	only  the  words  that   have   changed
	(usually they have been added).
-e gair
	use 'wordforms' from hunspell to expand
	the   given  word  with  all   relevant
	permitted  affixes in  the  dictionary.
-f gair
	find the word or word  fragment  in the
	dictionary  file and print all matches:
	accepts regex
-i
	repeatedly  prompt for words,  then  -a
	add them (this first checks if they are
	in  the  dictionary   already,  and  by
	default auto-tags with treigladau tags.
-n rhestr_o_eiriau.txt
	search through a list of words (one per
	line) to find ones unknown to the  dict
	and add them to an output file.
-s gair
	check  whether  word  'gair'  (or words
	in file 'gair') are in the dictionary.
-t
	sort the .dic file  alphabetically  and
	add the number of lines to the top."

			exit 3
			;;
	esac
}

ychwanegu () {
	###
	# add a word to the dictionary, optionally with prefix / suffix tags
	###
	autotag=1
	# remove any dictionary tags from the end i.e. rhywedd/M becomes rhywedd
	gair=$(sed -e "s|/.*||" <<< "$1")
	dictgair="$1"
	# print out matches or closest words
	gwirio "$gair"
	# empty if hunspell recognises the word
	anhysbys=$(hunspell -L -d dictionaries/cy_GB <<< "$gair")

	if [[ -n "$anhysbys" ]] ; then
		# offer to autotag word if tags were not found on the word
		if [[ $autotag -eq 1 ]] && [[ "$gair" != "$dictgair" ]] ; then
			echo "Not autotagging, tags already added."
			autotag=0
		elif [[ $autotag -eq 1 ]] ; then
			llaes=""
			meddal=""
			trwynol=""
			hprosth=""
			# mutations are only possible on certain word beginnings
			if [[ "$gair" =~ (^[ctpCTP][^hH].*) ]] ; then llaes="L" ; fi
			if [[ "$gair" =~ (^[ctpCTP][^hH].*|^[lL][lL].*|^[rR][hH].*|^[dD][^dD].*|^[gG].*|^[bB].*|^[Mm].*) ]] ; then meddal="M" ; fi
			if [[ "$gair" =~ (^[ctpCTP][^hH].*|^[dD][^dD].*|^[gG].*|^[bB].*) ]] ; then trwynol="T" ; fi
			if [[ "$gair" =~ ^[aeiouwyAEIOUWYâêîôûŵŷÂÊÎÔÛŴŶ].* ]] ; then hprosth="H" ; fi
			tags="/$llaes$meddal$trwynol$hprosth"
			if [[ "$tags" == "/" ]] ; then
				printf "Add word \"$gair\" with no tags detected? [y/n]"
			else
				dictgair="$gair$tags"
				printf "Add word \"$gair\" with tags $tags , or (a) add without tags? [y/n/a]"
			fi
			# get user response whether to add, use autotag variable to permit writing to dictionary
			read -n 1 -p " " ateb
			echo
			# will only write anything to dict if autotag != 1
			if [[ "$ateb" =~ [yY] ]] ; then autotag=0 ; fi
			if [[ "$ateb" =~ [aA] ]] ; then autotag=0 ; dictgair=$gair ; fi
		fi
		# Add word
		if [[ $autotag -ne 1 ]] ; then
			echo "Writing word \"$dictgair\" to dictionary"
			echo "$gair" >> dictionaries/word_list.txt
			echo "$dictgair" >> dictionaries/cy_GB.dic
			# Write number of lines to tmp
			tail -n +2 dictionaries/cy_GB.dic | sort -u | wc -l > dictionaries/dict.tmp
			# Write sorted words to tmp
			tail -n +2 dictionaries/cy_GB.dic | WC_ALL=C sort -u >> dictionaries/dict.tmp
			# Copy tmp back to mwy.dic
			mv dictionaries/dict.tmp dictionaries/cy_GB.dic
			echo "Added word."
		else
			echo "Not adding word."
		fi
	else
		printf ''
		#echo "\"$gair\" is already in dictionary"
	fi

	# contains any unknown words in the word list
	anhysbys=$(hunspell -L -d dictionaries/cy_GB dictionaries/word_list.txt)
	if [[ -n "$anhysbys" ]] ; then
		echo "The dictionary does not recognise the following:"
		echo "$anhysbys"
	fi
}

adeiladu () {
	###
	# make the libreoffice extension
	###
	echo "Building..."
	#clean the folder of oxts (which are just renamed zips)
	mv *.oxt archive/ 2> /dev/null

	# figure out which version we're building
	version=$(grep -rnw './description.xml' -e '<version value=')
	# remove xml stuff to just have the version data
	version=${version/*value=\"/}
	version=${version/\"*/}

	# zip the latest files
	zip -qr libreoffice-geiriadur-$version.oxt description/ META-INF/ dictionaries/cy_GB.dic dictionaries/cy_GB.aff baner_cymreig.png description.xml dictionaries.xcu LICENSE README.txt

	echo "Built."
}

geiriau_a_newidiwyd () {
	###
	# print out the dic word count, then the stems of any new words added
	# (i.e. everything before the '/' on any lines that have changed)
	###
	git diff dictionaries/cy_GB.dic | grep +[a-zA-Z0-9] | grep -v @ | sed -e 's/^+//g' -e 's/\/[a-zA-Z]*//g'
}

ystyried () {
	###
	# expand a word with all available relevant affixes: the below is modified from 'wordforms'
	# from https://github.com/hunspell/hunspell/blob/master/src/tools/wordforms
	###
	# check for incorrect number of arguments
	case $# in
		0|1|2) echo "Usage: wordforms [-s | -p] dictionary.aff dictionary.dic word
	-s: print only suffixed forms
	-p: print only prefixed forms";
		exit 1;;
	esac
	# this switches whether to print only suffixed, prefixed or all forms of stem
	fx=0
	case $1 in
		-s) fx=1; shift;;
		-p) fx=2; shift;;
	esac
	# clear any previous temporary dictionary
	test -h /tmp/wordforms.aff && rm /tmp/wordforms.aff
	# make a symbolic link of the aff file
	ln -s "$PWD/$1" /tmp/wordforms.aff
	# prepared dic only contains the query word
	# TODO this will not find the stem properly
	echo 1 >/tmp/wordforms.dic
	grep "^$3/" $2 >>/tmp/wordforms.dic
	# awk magic: seems to add every affix to the stem and then lets
	# hunspell and the original dictionary filter out the bad entries
	echo $3 | awk -v "fx=$fx" '
	fx!=2 && FILENAME!="-" && /^SFX/ && NF > 4{split($4,a,"/");clen=($3=="0") ? 0 : length($3);sfx[a[1],clen]=a[1];sfxc[a[1],clen]=clen;next}
	fx!=1 && FILENAME!="-" && /^PFX/ && NF > 4{split($4,a,"/");clen=($3=="0") ? 0 : length($3);pfx[a[1],clen]=a[1];pfxc[a[1],clen]=clen;next}
	FILENAME=="-"{
		wlen=length($1)
		if (fx==0 || fx==2) {
			for (j in pfx) {if (wlen<=pfxc[j]) continue; print (pfx[j]=="0" ? "" : pfx[j]) substr($1, pfxc[j]+1)}
		}
		if (fx==0 || fx==1) {
			for(i in sfx){clen=sfxc[i];if (wlen<=clen) continue; print substr($1, 1, wlen-clen) (sfx[i]=="0" ? "": sfx[i]) }
		}
		if (fx==0) {
			for (j in pfx) {if (wlen<=pfxc[j]) continue;
				for(i in sfx){clen=sfxc[i];if (wlen<=clen || wlen <= (clen + pfxc[j]))continue;
					print (pfx[j]=="0" ? "" : pfx[j]) substr($1, pfxc[j]+1, wlen-clen-pfxc[j]) (sfx[i]=="0" ? "": sfx[i])
				}
			}
		}
	}
	' /tmp/wordforms.aff - | hunspell -d /tmp/wordforms -G -l
}

ffeindio () {
	###
	# find dictionary entry matching search term (basically just grep)
	###
	cat dictionaries/cy_GB.dic | grep "$1"
}

insertmode () {
	while :
	do
		echo
		printf "Word: "
		read word
		ychwanegu "$word"
	done
}

newydd () {
	###
	# search through a list of words and add the unknown ones to a file
	###
	touch dictionaries/newydd.txt
	hunspell -d dictionaries/cy_GB -L dictionaries/newydd.txt > dictionaries/newydd.tmp
	hunspell -d dictionaries/cy_GB -L $1 >> dictionaries/newydd.tmp
	sort -u dictionaries/newydd.tmp > dictionaries/newydd.txt
	rm dictionaries/newydd.tmp
}

gwirio () {
	###
	# check whether a word is in the dictionary
	# if $1 is a file, check through it for non
	# -english words that aren't in the cymraeg
	# dictionary either
	###
	# TODO: backslash-escaped filenames with spaces don't work with the -f
	if [ -f "$1" ] ; then
		cat $1 | hunspell -l -d dictionaries/cy_GB | hunspell -l -d en_GB | sort -u | uniq -u | tr ' ' '\n'
	else
		response=$(tail -n1 <<< "$(echo $1 | hunspell -d dictionaries/cy_GB -a)")
		case ${response:0:1} in
			"*")
				echo "Correct, in dictionary."
				shift
				;;
			"&")
				echo -e "Closest matches:\t$(sed 's/^.*[:] //g' <<< $response)"
				shift
				;;
			"+")
				echo "Found using affix removal."
				shift
				;;
			"-")
				echo "Found, compound."
				shift
				;;
			"#")
				echo "Unknown word, no suggestions."
				shift
				;;
		esac
	fi
}

tacluso () {
	###
	# tidy the dic file without adding or removing lines
	###
	tail -n +2 $1 | sort -u | wc -l > dictionaries/dict.tmp
	tail -n +2 $1 | WC_ALL=C sort -u >> dictionaries/dict.tmp
	mv dictionaries/dict.tmp $1
}

smallflags () {
	# abc/ABCabc format typically
	# capture what this returns for just the small flags on a line
	intext=$1
	# catch no flags, otherwise return lowercase flags
	if [[ "$intext" == $( sed -e "s|/||" <<< $intext ) ]] ; then
		echo ""
	else
		echo $( sed -e "s|.*/||" -e "s|[A-Z]*||g" <<< $intext )
	fi
}

capsflags () {
	# abc/ABCabc format typically
	# capture what this returns for just the capital flags on a line
	intext=$1
	# catch no flags, otherwise return uppercase flags
	if [[ "$intext" == $( sed -e "s|/||" <<< $intext ) ]] ; then
		echo ""
	else
		echo $( sed -e "s|.*/||" -e "s|[a-z]*||g" <<< $intext )
	fi
}

noflags () {
	# abc/ABCabc format typically
	# capture what this returns for just the line without flags or delimiter /
	intext=$1
	# catch no flags, otherwise return dic entry without flags or /
	if [[ "$intext" == $( sed -e "s|/||" <<< $intext ) ]] ; then
		echo $intext
	else
		echo $( sed -e "s|/.*||" <<< $intext )
	fi
}

addflag () {
	# return in abc/ABCabc format
	# capture what this returns for the same line with
	# the flag added to the corresponding flag grouping
	# i.e. assuming input "abc/ABcde X" this will return
	# abc/ABXcde, or "abc/ABcde x" for abc/ABcdex
	intext=$1
	inflag=$2
	echo $( noflags $intext )"/"$( capsflags $intext )$( sed "s|[a-z]*||g" <<< $inflag )$( smallflags $intext )$( sed "s|[A-Z]*||g" <<< $inflag )
}

checkmutationflags () {
	# capture what this returns to check if the line has
	# "normal" mutation rules applied to it or not
	line=$1
	flags=$( capsflags $line )
	lemma=$( noflags $line )
	lemma=${lemma,,} #lowercase
	# strip out everything except the mutation flags
	mutflags=$( sed "s|[^LMTH]||g" <<< $flags )
	# sort flags alphabetically
	mutflags=$( echo $mutflags | grep -o . | sort | tr -d "\n" )
	# now figure out the expected mutation flags and
	# compare with the mutation flags we actually have
	expflags=""
	if [[ ${lemma::1} =~ [aeiouwyâêîôûŵŷï] ]] ; then expflags="H" ; fi
	if [[ ${lemma::1} =~ [gbm] ]] || [[ ${lemma::2} =~ d[^d] ]] || [[ ${lemma::2} =~ ll ]] || [[ ${lemma::2} =~ rh ]] || [[ ${lemma::2} =~ [cpt][^h] ]] ; then expflags=$expflags"M" ; fi
	if [[ ${lemma::1} =~ [gb] ]] || [[ ${lemma::2} =~ [cpt][^h] ]] || [[ ${lemma::2} =~ [d][^d] ]] ; then expflags=$expflags"T" ; fi
	if [[ ${lemma::2} =~ [cp][^h] ]] || [[ ${lemma::2} =~ [t][^hs] ]] ; then expflags=$expflags"L" ; fi
	expflags=$( echo $expflags | grep -o . | sort | tr -d "\n" )
	if [[ "$mutflags" == "$expflags" ]] ; then echo 0 ; else echo 1 ; fi
}

parse $1 $2
